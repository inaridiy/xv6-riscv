diff --git a/.vscode/settings.json b/.vscode/settings.json
index 52cc12c..989b333 100644
--- a/.vscode/settings.json
+++ b/.vscode/settings.json
@@ -4,7 +4,8 @@
         "typeinfo": "c",
         "fs.h": "c",
         "user.h": "c",
-        "types.h": "c"
+        "types.h": "c",
+        "defs.h": "c"
     },
     "[c]": {
         "editor.defaultFormatter": "ms-vscode.cpptools"
diff --git a/Makefile b/Makefile
index 41210be..846515f 100644
--- a/Makefile
+++ b/Makefile
@@ -26,13 +26,14 @@ OBJS = \
   $K/pipe.o \
   $K/exec.o \
   $K/sysfile.o \
+  $K/syskmtk.o \
   $K/kernelvec.o \
   $K/plic.o \
   $K/virtio_disk.o
 
 # riscv64-unknown-elf- or riscv64-linux-gnu-
 # perhaps in /opt/riscv/bin
-#TOOLPREFIX = 
+#TOOLPREFIX =
 
 # Try to infer the correct TOOLPREFIX if not set
 ifndef TOOLPREFIX
@@ -74,7 +75,7 @@ endif
 LDFLAGS = -z max-page-size=4096
 
 $K/kernel: $(OBJS) $K/kernel.ld $U/initcode
-	$(LD) $(LDFLAGS) -T $K/kernel.ld -o $K/kernel $(OBJS) 
+	$(LD) $(LDFLAGS) -T $K/kernel.ld -o $K/kernel $(OBJS)
 	$(OBJDUMP) -S $K/kernel > $K/kernel.asm
 	$(OBJDUMP) -t $K/kernel | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $K/kernel.sym
 
@@ -119,6 +120,11 @@ UPROGS=\
 	$U/_cat\
 	$U/_echo\
 	$U/_echoecho\
+	$U/_prime\
+	$U/_pwd\
+	$U/_simple_shell\
+	$U/_pipe_test\
+	$U/_kmtk_test\
 	$U/_hello_sfc\
 	$U/_forktest\
 	$U/_grep\
@@ -140,7 +146,7 @@ fs.img: mkfs/mkfs README $(UPROGS)
 
 -include kernel/*.d user/*.d
 
-clean: 
+clean:
 	rm -f *.tex *.dvi *.idx *.aux *.log *.ind *.ilg \
 	*/*.o */*.d */*.asm */*.sym \
 	$U/initcode $U/initcode.out $K/kernel fs.img \
diff --git a/diff b/diff
new file mode 100644
index 0000000..8a5a0c7
--- /dev/null
+++ b/diff
@@ -0,0 +1,675 @@
+diff --git a/.vscode/settings.json b/.vscode/settings.json
+index 52cc12c..989b333 100644
+--- a/.vscode/settings.json
++++ b/.vscode/settings.json
+@@ -4,7 +4,8 @@
+         "typeinfo": "c",
+         "fs.h": "c",
+         "user.h": "c",
+-        "types.h": "c"
++        "types.h": "c",
++        "defs.h": "c"
+     },
+     "[c]": {
+         "editor.defaultFormatter": "ms-vscode.cpptools"
+diff --git a/Makefile b/Makefile
+index 41210be..34b3816 100644
+--- a/Makefile
++++ b/Makefile
+@@ -26,13 +26,14 @@ OBJS = \
+   $K/pipe.o \
+   $K/exec.o \
+   $K/sysfile.o \
++  $K/syskmtk.o \
+   $K/kernelvec.o \
+   $K/plic.o \
+   $K/virtio_disk.o
+ 
+ # riscv64-unknown-elf- or riscv64-linux-gnu-
+ # perhaps in /opt/riscv/bin
+-#TOOLPREFIX = 
++#TOOLPREFIX =
+ 
+ # Try to infer the correct TOOLPREFIX if not set
+ ifndef TOOLPREFIX
+@@ -74,7 +75,7 @@ endif
+ LDFLAGS = -z max-page-size=4096
+ 
+ $K/kernel: $(OBJS) $K/kernel.ld $U/initcode
+-	$(LD) $(LDFLAGS) -T $K/kernel.ld -o $K/kernel $(OBJS) 
++	$(LD) $(LDFLAGS) -T $K/kernel.ld -o $K/kernel $(OBJS)
+ 	$(OBJDUMP) -S $K/kernel > $K/kernel.asm
+ 	$(OBJDUMP) -t $K/kernel | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $K/kernel.sym
+ 
+@@ -119,6 +120,10 @@ UPROGS=\
+ 	$U/_cat\
+ 	$U/_echo\
+ 	$U/_echoecho\
++	$U/_prime\
++	$U/_simple_shell\
++	$U/_pipe_test\
++	$U/_kmtk_test\
+ 	$U/_hello_sfc\
+ 	$U/_forktest\
+ 	$U/_grep\
+@@ -140,7 +145,7 @@ fs.img: mkfs/mkfs README $(UPROGS)
+ 
+ -include kernel/*.d user/*.d
+ 
+-clean: 
++clean:
+ 	rm -f *.tex *.dvi *.idx *.aux *.log *.ind *.ilg \
+ 	*/*.o */*.d */*.asm */*.sym \
+ 	$U/initcode $U/initcode.out $K/kernel fs.img \
+diff --git a/kernel/syscall.c b/kernel/syscall.c
+index ed65409..46519d3 100644
+--- a/kernel/syscall.c
++++ b/kernel/syscall.c
+@@ -8,24 +8,22 @@
+ #include "defs.h"
+ 
+ // Fetch the uint64 at addr from the current process.
+-int
+-fetchaddr(uint64 addr, uint64 *ip)
++int fetchaddr(uint64 addr, uint64 *ip)
+ {
+   struct proc *p = myproc();
+-  if(addr >= p->sz || addr+sizeof(uint64) > p->sz) // both tests needed, in case of overflow
++  if (addr >= p->sz || addr + sizeof(uint64) > p->sz) // both tests needed, in case of overflow
+     return -1;
+-  if(copyin(p->pagetable, (char *)ip, addr, sizeof(*ip)) != 0)
++  if (copyin(p->pagetable, (char *)ip, addr, sizeof(*ip)) != 0)
+     return -1;
+   return 0;
+ }
+ 
+ // Fetch the nul-terminated string at addr from the current process.
+ // Returns length of string, not including nul, or -1 for error.
+-int
+-fetchstr(uint64 addr, char *buf, int max)
++int fetchstr(uint64 addr, char *buf, int max)
+ {
+   struct proc *p = myproc();
+-  if(copyinstr(p->pagetable, buf, addr, max) < 0)
++  if (copyinstr(p->pagetable, buf, addr, max) < 0)
+     return -1;
+   return strlen(buf);
+ }
+@@ -34,7 +32,8 @@ static uint64
+ argraw(int n)
+ {
+   struct proc *p = myproc();
+-  switch (n) {
++  switch (n)
++  {
+   case 0:
+     return p->trapframe->a0;
+   case 1:
+@@ -53,8 +52,7 @@ argraw(int n)
+ }
+ 
+ // Fetch the nth 32-bit system call argument.
+-void
+-argint(int n, int *ip)
++void argint(int n, int *ip)
+ {
+   *ip = argraw(n);
+ }
+@@ -62,8 +60,7 @@ argint(int n, int *ip)
+ // Retrieve an argument as a pointer.
+ // Doesn't check for legality, since
+ // copyin/copyout will do that.
+-void
+-argaddr(int n, uint64 *ip)
++void argaddr(int n, uint64 *ip)
+ {
+   *ip = argraw(n);
+ }
+@@ -71,8 +68,7 @@ argaddr(int n, uint64 *ip)
+ // Fetch the nth word-sized system call argument as a null-terminated string.
+ // Copies into buf, at most max.
+ // Returns string length if OK (including nul), -1 if error.
+-int
+-argstr(int n, char *buf, int max)
++int argstr(int n, char *buf, int max)
+ {
+   uint64 addr;
+   argaddr(n, &addr);
+@@ -101,47 +97,51 @@ extern uint64 sys_unlink(void);
+ extern uint64 sys_link(void);
+ extern uint64 sys_mkdir(void);
+ extern uint64 sys_close(void);
++extern uint64 sys_kmtk(void);
+ 
+ // An array mapping syscall numbers from syscall.h
+ // to the function that handles the system call.
+ static uint64 (*syscalls[])(void) = {
+-[SYS_fork]    sys_fork,
+-[SYS_exit]    sys_exit,
+-[SYS_wait]    sys_wait,
+-[SYS_pipe]    sys_pipe,
+-[SYS_read]    sys_read,
+-[SYS_kill]    sys_kill,
+-[SYS_exec]    sys_exec,
+-[SYS_fstat]   sys_fstat,
+-[SYS_chdir]   sys_chdir,
+-[SYS_dup]     sys_dup,
+-[SYS_getpid]  sys_getpid,
+-[SYS_sbrk]    sys_sbrk,
+-[SYS_sleep]   sys_sleep,
+-[SYS_uptime]  sys_uptime,
+-[SYS_open]    sys_open,
+-[SYS_write]   sys_write,
+-[SYS_mknod]   sys_mknod,
+-[SYS_unlink]  sys_unlink,
+-[SYS_link]    sys_link,
+-[SYS_mkdir]   sys_mkdir,
+-[SYS_close]   sys_close,
++    [SYS_fork] sys_fork,
++    [SYS_exit] sys_exit,
++    [SYS_wait] sys_wait,
++    [SYS_pipe] sys_pipe,
++    [SYS_read] sys_read,
++    [SYS_kill] sys_kill,
++    [SYS_exec] sys_exec,
++    [SYS_fstat] sys_fstat,
++    [SYS_chdir] sys_chdir,
++    [SYS_dup] sys_dup,
++    [SYS_getpid] sys_getpid,
++    [SYS_sbrk] sys_sbrk,
++    [SYS_sleep] sys_sleep,
++    [SYS_uptime] sys_uptime,
++    [SYS_open] sys_open,
++    [SYS_write] sys_write,
++    [SYS_mknod] sys_mknod,
++    [SYS_unlink] sys_unlink,
++    [SYS_link] sys_link,
++    [SYS_mkdir] sys_mkdir,
++    [SYS_close] sys_close,
++    [SYS_kmtk] sys_kmtk,
+ };
+ 
+-void
+-syscall(void)
++void syscall(void)
+ {
+   int num;
+   struct proc *p = myproc();
+ 
+   num = p->trapframe->a7;
+-  if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
++  if (num > 0 && num < NELEM(syscalls) && syscalls[num])
++  {
+     // Use num to lookup the system call function for num, call it,
+     // and store its return value in p->trapframe->a0
+     p->trapframe->a0 = syscalls[num]();
+-  } else {
++  }
++  else
++  {
+     printf("%d %s: unknown sys call %d\n",
+-            p->pid, p->name, num);
++           p->pid, p->name, num);
+     p->trapframe->a0 = -1;
+   }
+ }
+diff --git a/kernel/syscall.h b/kernel/syscall.h
+index bc5f356..e85f70f 100644
+--- a/kernel/syscall.h
++++ b/kernel/syscall.h
+@@ -1,22 +1,23 @@
+ // System call numbers
+-#define SYS_fork    1
+-#define SYS_exit    2
+-#define SYS_wait    3
+-#define SYS_pipe    4
+-#define SYS_read    5
+-#define SYS_kill    6
+-#define SYS_exec    7
+-#define SYS_fstat   8
+-#define SYS_chdir   9
+-#define SYS_dup    10
++#define SYS_fork 1
++#define SYS_exit 2
++#define SYS_wait 3
++#define SYS_pipe 4
++#define SYS_read 5
++#define SYS_kill 6
++#define SYS_exec 7
++#define SYS_fstat 8
++#define SYS_chdir 9
++#define SYS_dup 10
+ #define SYS_getpid 11
+-#define SYS_sbrk   12
+-#define SYS_sleep  13
++#define SYS_sbrk 12
++#define SYS_sleep 13
+ #define SYS_uptime 14
+-#define SYS_open   15
+-#define SYS_write  16
+-#define SYS_mknod  17
++#define SYS_open 15
++#define SYS_write 16
++#define SYS_mknod 17
+ #define SYS_unlink 18
+-#define SYS_link   19
+-#define SYS_mkdir  20
+-#define SYS_close  21
++#define SYS_link 19
++#define SYS_mkdir 20
++#define SYS_close 21
++#define SYS_kmtk 22
+\ No newline at end of file
+diff --git a/kernel/syskmtk.c b/kernel/syskmtk.c
+new file mode 100644
+index 0000000..96eeb46
+--- /dev/null
++++ b/kernel/syskmtk.c
+@@ -0,0 +1,4 @@
++int sys_kmtk(void)
++{
++    return 114514;
++}
+diff --git a/more.c b/more.c
+new file mode 100644
+index 0000000..a335f3c
+--- /dev/null
++++ b/more.c
+@@ -0,0 +1,59 @@
++#include <stdio.h>    // 標準入出力関連の関数を使用するためのヘッダ
++#include <stdlib.h>   // 汎用ユーティリティ関数（exitなど）を使用するためのヘッダ
++#include <unistd.h>   // UNIX標準API（fork, pipe, read, writeなど）を使用するためのヘッダ
++#include <fcntl.h>    // ファイル制御（open関数など）を使用するためのヘッダ
++#include <sys/wait.h> // プロセス制御（wait関数）を使用するためのヘッダ
++
++int main(int ac, char *av[])
++{
++    int fds[2];    // パイプ用のファイルディスクリプタ配列
++    int infd;      // 入力ファイルのファイルディスクリプタ
++    int cc;        // 読み込んだバイト数を保存する変数
++    char buf[512]; // ファイルから読み込むデータを一時的に保存するバッファ
++    pid_t pid;     // プロセスIDを保存する変数
++    int status;    // 子プロセスの終了ステータスを保存する変数
++
++    // 引数の数が正しくない場合、エラーメッセージを表示して終了
++    if (ac != 2)
++    {
++        fprintf(stderr, "usage: %s file\n", av[0]);
++        exit(1);
++    }
++
++    // 指定されたファイルを読み取り専用でオープン
++    if ((infd = open(av[1], O_RDONLY)) < 0)
++    {
++        fprintf(stderr, "Cannot open: %s\n", av[1]);
++        exit(1);
++    }
++
++    // パイプを作成
++    if (pipe(fds) < 0)
++    {
++        perror("pipe");
++        exit(1);
++    }
++
++    // 子プロセスを作成
++    if ((pid = fork()) == 0)
++    {
++        // 子プロセスの処理
++        close(0); // 標準入力を閉じる
++        if (dup(fds[0]) < 0)
++        { // パイプの読み込み端を標準入力に複製
++            perror("dup");
++            exit(1);
++        }
++        execl("/usr/bin/more", "more", (char *)0); // moreコマンドを実行
++        exit(0);                                   // moreの実行が終了したら子プロセスを終了
++    }
++
++    // 親プロセスの処理
++    while ((cc = read(infd, buf, sizeof(buf))) != 0)
++    {                           // ファイルからデータを読み込む
++        write(fds[1], buf, cc); // パイプの書き込み端にデータを書き込む
++    }
++    close(infd);   // 入力ファイルを閉じる
++    close(fds[1]); // パイプの書き込み端を閉じる
++    wait(&status); // 子プロセスの終了を待つ
++}
+diff --git a/user/kmtk_test.c b/user/kmtk_test.c
+new file mode 100644
+index 0000000..1b18323
+--- /dev/null
++++ b/user/kmtk_test.c
+@@ -0,0 +1,10 @@
++#include "kernel/types.h"
++#include "kernel/stat.h"
++#include "user/user.h"
++
++int main(int argc, char *argv[])
++{
++    int kmtk_result = kmtk();
++    printf("kmtk() returned %d\n", kmtk_result);
++    exit(0);
++}
+diff --git a/user/more.c b/user/more.c
+new file mode 100644
+index 0000000..a69b28d
+--- /dev/null
++++ b/user/more.c
+@@ -0,0 +1,51 @@
++#include "kernel/types.h"
++#include "kernel/stat.h"
++#include "user/user.h"
++
++int main(int argc, char *argv[])
++{
++    int fds[2];
++    int fd;
++    int n;
++    char buf[512];
++
++    if (argc != 2)
++    {
++        printf(2, "usage: %s file\n", argv[0]);
++        exit(0);
++    }
++
++    if ((fd = open(argv[1], 0)) < 0)
++    { // O_RDONLYはxv6では通常0です
++        printf(2, "Cannot open %s\n", argv[1]);
++        exit(0);
++    }
++
++    if (pipe(fds) < 0)
++    {
++        printf(2, "pipe failed\n");
++        exit(0);
++    }
++
++    if (fork() == 0)
++    {
++        close(0);
++        dup(fds[0], 0);
++        close(fds[0]);
++        close(fds[1]);
++        char *args[] = {"more", 0}; // xv6ではexecを使用して直接配列を渡す
++        exec("more", args);
++        printf(2, "exec more failed\n");
++        exit(0);
++    }
++
++    close(fds[0]);
++    while ((n = read(fd, buf, sizeof(buf))) > 0)
++    {
++        write(fds[1], buf, n);
++    }
++    close(fd);
++    close(fds[1]);
++    wait(0);
++    exit(0);
++}
+diff --git a/user/pipe_test.c b/user/pipe_test.c
+new file mode 100644
+index 0000000..6ba6041
+--- /dev/null
++++ b/user/pipe_test.c
+@@ -0,0 +1,38 @@
++#include "kernel/types.h"
++#include "kernel/stat.h"
++#include "user/user.h"
++
++int main(void)
++{
++    int p[2];
++    char *argv[2];
++    argv[1] = 0;
++
++    // パイプ作成
++    pipe(p);
++
++    if (fork() == 0)
++    {
++        // 子プロセス
++        close(1);    // 標準出力を閉じる
++        dup(p[1]);   // パイプの書き込み側を標準出力に複製
++        close(p[0]); // パイプの読み込み側は不要なので閉じる
++        close(p[1]);
++
++        argv[0] = "ls";
++        exec("ls", argv);
++        exit(1);
++    }
++    else
++    {
++        // 親プロセス
++        close(0);    // 標準入力を閉じる
++        dup(p[0]);   // パイプの読み込み側を標準入力に複製
++        close(p[1]); // パイプの書き込み側は不要なので閉じる
++        close(p[0]);
++
++        argv[0] = "wc";
++        exec("wc", argv);
++    }
++    exit(0);
++}
+diff --git a/user/prime.c b/user/prime.c
+new file mode 100644
+index 0000000..11594ef
+--- /dev/null
++++ b/user/prime.c
+@@ -0,0 +1,65 @@
++#include "kernel/types.h"
++#include "user/user.h"
++
++void sieve(int read_fd)
++{
++    int prime;
++    if (read(read_fd, &prime, sizeof(prime)) <= 0)
++    {
++        close(read_fd);
++        exit(0);
++    }
++
++    printf("prime %d\n", prime);
++
++    int new_fd[2];
++    pipe(new_fd);
++
++    if (fork() == 0)
++    {
++        close(new_fd[1]); // 新しい子プロセスで書き込み端を閉じる
++        sieve(new_fd[0]); // レシーブ側パイプで再帰的に呼び出し
++    }
++    else
++    {
++        close(new_fd[0]); // 親プロセスでは読み込み端を閉じる
++        int num;
++        while (read(read_fd, &num, sizeof(num)) > 0)
++        {
++            if (num % prime != 0)
++            {
++                write(new_fd[1], &num, sizeof(num)); // 割り切れない数を次のプロセスに渡す
++            }
++        }
++        close(new_fd[1]);
++        wait(0); // 子プロセスの終了を待つ
++        close(read_fd);
++        exit(0);
++    }
++}
++
++int main(int argc, char *argv[])
++{
++    int check_max = 1000000000;
++    int fds[2];
++
++    pipe(fds);
++
++    if (fork() != 0)
++    {
++        close(fds[0]); // 親プロセスは読み込み側を閉じる
++        for (int i = 2; i <= check_max; i++)
++        {
++            write(fds[1], &i, sizeof(i));
++        }
++        close(fds[1]); // 数値の書き込み完了後に書き込み側を閉じる
++        wait(0);       // 子プロセスの終了を待つ
++    }
++    else
++    {
++        close(fds[1]); // 子プロセスは書き込み側を閉じる
++        sieve(fds[0]); // 読み込み側で数値をフィルタリング
++    }
++
++    exit(0);
++}
+diff --git a/user/simple_shell.c b/user/simple_shell.c
+new file mode 100644
+index 0000000..208844e
+--- /dev/null
++++ b/user/simple_shell.c
+@@ -0,0 +1,54 @@
++#include "kernel/types.h"
++#include "kernel/stat.h"
++#include "user/user.h"
++#include "kernel/fs.h"
++
++char buf[100];
++
++void simple_shell()
++{
++    int pid, wpid;
++    while (1)
++    {
++        // プロンプト表示
++        write(1, "$$$ ", 2);
++
++        // コマンド入力
++        memset(buf, 0, sizeof(buf));
++        gets(buf, sizeof(buf));
++        buf[strlen(buf) - 1] = 0; // 改行文字の削除
++
++        if (buf[0] == 0)
++            continue; // 入力がない場合はスキップ
++
++        // exitコマンド
++        if (strcmp(buf, "exit") == 0)
++        {
++            exit(0);
++        }
++
++        // コマンド実行
++        if ((pid = fork()) == 0)
++        {
++            // 子プロセスでコマンド実行
++            char *argv[2];
++            argv[0] = buf; // コマンド
++            argv[1] = 0;   // 引数の終わり
++            exec(buf, argv);
++            printf("exec %s failed\n", buf);
++            exit(1);
++        }
++        else
++        {
++            // 親プロセスで子プロセスの終了を待つ
++            while ((wpid = wait((int *)0)) >= 0 && wpid != pid)
++                ; // 子プロセスの終了を待つ
++        }
++    }
++}
++
++int main(void)
++{
++    simple_shell();
++    exit(0);
++}
+diff --git a/user/user.h b/user/user.h
+index 4d398d5..3b65898 100644
+--- a/user/user.h
++++ b/user/user.h
+@@ -3,39 +3,40 @@ struct stat;
+ // system calls
+ int fork(void);
+ int exit(int) __attribute__((noreturn));
+-int wait(int*);
+-int pipe(int*);
+-int write(int, const void*, int);
+-int read(int, void*, int);
++int wait(int *);
++int pipe(int *);
++int write(int, const void *, int);
++int read(int, void *, int);
+ int close(int);
+ int kill(int);
+-int exec(const char*, char**);
+-int open(const char*, int);
+-int mknod(const char*, short, short);
+-int unlink(const char*);
+-int fstat(int fd, struct stat*);
+-int link(const char*, const char*);
+-int mkdir(const char*);
+-int chdir(const char*);
++int exec(const char *, char **);
++int open(const char *, int);
++int mknod(const char *, short, short);
++int unlink(const char *);
++int fstat(int fd, struct stat *);
++int link(const char *, const char *);
++int mkdir(const char *);
++int chdir(const char *);
+ int dup(int);
+ int getpid(void);
+-char* sbrk(int);
++char *sbrk(int);
+ int sleep(int);
+ int uptime(void);
++int kmtk(void);
+ 
+ // ulib.c
+-int stat(const char*, struct stat*);
+-char* strcpy(char*, const char*);
+-void *memmove(void*, const void*, int);
+-char* strchr(const char*, char c);
+-int strcmp(const char*, const char*);
+-void fprintf(int, const char*, ...);
+-void printf(const char*, ...);
+-char* gets(char*, int max);
+-uint strlen(const char*);
+-void* memset(void*, int, uint);
+-void* malloc(uint);
+-void free(void*);
+-int atoi(const char*);
++int stat(const char *, struct stat *);
++char *strcpy(char *, const char *);
++void *memmove(void *, const void *, int);
++char *strchr(const char *, char c);
++int strcmp(const char *, const char *);
++void fprintf(int, const char *, ...);
++void printf(const char *, ...);
++char *gets(char *, int max);
++uint strlen(const char *);
++void *memset(void *, int, uint);
++void *malloc(uint);
++void free(void *);
++int atoi(const char *);
+ int memcmp(const void *, const void *, uint);
+ void *memcpy(void *, const void *, uint);
+diff --git a/user/usys.pl b/user/usys.pl
+index 01e426e..000c622 100755
+--- a/user/usys.pl
++++ b/user/usys.pl
+@@ -14,7 +14,7 @@ sub entry {
+     print " ecall\n";
+     print " ret\n";
+ }
+-	
++
+ entry("fork");
+ entry("exit");
+ entry("wait");
+@@ -36,3 +36,4 @@ entry("getpid");
+ entry("sbrk");
+ entry("sleep");
+ entry("uptime");
++entry("kmtk")
+\ No newline at end of file
diff --git a/kernel/syscall.c b/kernel/syscall.c
index ed65409..6afee81 100644
--- a/kernel/syscall.c
+++ b/kernel/syscall.c
@@ -8,24 +8,22 @@
 #include "defs.h"
 
 // Fetch the uint64 at addr from the current process.
-int
-fetchaddr(uint64 addr, uint64 *ip)
+int fetchaddr(uint64 addr, uint64 *ip)
 {
   struct proc *p = myproc();
-  if(addr >= p->sz || addr+sizeof(uint64) > p->sz) // both tests needed, in case of overflow
+  if (addr >= p->sz || addr + sizeof(uint64) > p->sz) // both tests needed, in case of overflow
     return -1;
-  if(copyin(p->pagetable, (char *)ip, addr, sizeof(*ip)) != 0)
+  if (copyin(p->pagetable, (char *)ip, addr, sizeof(*ip)) != 0)
     return -1;
   return 0;
 }
 
 // Fetch the nul-terminated string at addr from the current process.
 // Returns length of string, not including nul, or -1 for error.
-int
-fetchstr(uint64 addr, char *buf, int max)
+int fetchstr(uint64 addr, char *buf, int max)
 {
   struct proc *p = myproc();
-  if(copyinstr(p->pagetable, buf, addr, max) < 0)
+  if (copyinstr(p->pagetable, buf, addr, max) < 0)
     return -1;
   return strlen(buf);
 }
@@ -34,7 +32,8 @@ static uint64
 argraw(int n)
 {
   struct proc *p = myproc();
-  switch (n) {
+  switch (n)
+  {
   case 0:
     return p->trapframe->a0;
   case 1:
@@ -53,8 +52,7 @@ argraw(int n)
 }
 
 // Fetch the nth 32-bit system call argument.
-void
-argint(int n, int *ip)
+void argint(int n, int *ip)
 {
   *ip = argraw(n);
 }
@@ -62,8 +60,7 @@ argint(int n, int *ip)
 // Retrieve an argument as a pointer.
 // Doesn't check for legality, since
 // copyin/copyout will do that.
-void
-argaddr(int n, uint64 *ip)
+void argaddr(int n, uint64 *ip)
 {
   *ip = argraw(n);
 }
@@ -71,8 +68,7 @@ argaddr(int n, uint64 *ip)
 // Fetch the nth word-sized system call argument as a null-terminated string.
 // Copies into buf, at most max.
 // Returns string length if OK (including nul), -1 if error.
-int
-argstr(int n, char *buf, int max)
+int argstr(int n, char *buf, int max)
 {
   uint64 addr;
   argaddr(n, &addr);
@@ -101,47 +97,53 @@ extern uint64 sys_unlink(void);
 extern uint64 sys_link(void);
 extern uint64 sys_mkdir(void);
 extern uint64 sys_close(void);
+extern uint64 sys_kmtk(void);
+extern uint64 sys_myfds(void);
 
 // An array mapping syscall numbers from syscall.h
 // to the function that handles the system call.
 static uint64 (*syscalls[])(void) = {
-[SYS_fork]    sys_fork,
-[SYS_exit]    sys_exit,
-[SYS_wait]    sys_wait,
-[SYS_pipe]    sys_pipe,
-[SYS_read]    sys_read,
-[SYS_kill]    sys_kill,
-[SYS_exec]    sys_exec,
-[SYS_fstat]   sys_fstat,
-[SYS_chdir]   sys_chdir,
-[SYS_dup]     sys_dup,
-[SYS_getpid]  sys_getpid,
-[SYS_sbrk]    sys_sbrk,
-[SYS_sleep]   sys_sleep,
-[SYS_uptime]  sys_uptime,
-[SYS_open]    sys_open,
-[SYS_write]   sys_write,
-[SYS_mknod]   sys_mknod,
-[SYS_unlink]  sys_unlink,
-[SYS_link]    sys_link,
-[SYS_mkdir]   sys_mkdir,
-[SYS_close]   sys_close,
+    [SYS_fork] sys_fork,
+    [SYS_exit] sys_exit,
+    [SYS_wait] sys_wait,
+    [SYS_pipe] sys_pipe,
+    [SYS_read] sys_read,
+    [SYS_kill] sys_kill,
+    [SYS_exec] sys_exec,
+    [SYS_fstat] sys_fstat,
+    [SYS_chdir] sys_chdir,
+    [SYS_dup] sys_dup,
+    [SYS_getpid] sys_getpid,
+    [SYS_sbrk] sys_sbrk,
+    [SYS_sleep] sys_sleep,
+    [SYS_uptime] sys_uptime,
+    [SYS_open] sys_open,
+    [SYS_write] sys_write,
+    [SYS_mknod] sys_mknod,
+    [SYS_unlink] sys_unlink,
+    [SYS_link] sys_link,
+    [SYS_mkdir] sys_mkdir,
+    [SYS_close] sys_close,
+    [SYS_kmtk] sys_kmtk,
+    [SYS_myfds] sys_myfds,
 };
 
-void
-syscall(void)
+void syscall(void)
 {
   int num;
   struct proc *p = myproc();
 
   num = p->trapframe->a7;
-  if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
+  if (num > 0 && num < NELEM(syscalls) && syscalls[num])
+  {
     // Use num to lookup the system call function for num, call it,
     // and store its return value in p->trapframe->a0
     p->trapframe->a0 = syscalls[num]();
-  } else {
+  }
+  else
+  {
     printf("%d %s: unknown sys call %d\n",
-            p->pid, p->name, num);
+           p->pid, p->name, num);
     p->trapframe->a0 = -1;
   }
 }
diff --git a/kernel/syscall.h b/kernel/syscall.h
index bc5f356..00566c5 100644
--- a/kernel/syscall.h
+++ b/kernel/syscall.h
@@ -1,22 +1,24 @@
 // System call numbers
-#define SYS_fork    1
-#define SYS_exit    2
-#define SYS_wait    3
-#define SYS_pipe    4
-#define SYS_read    5
-#define SYS_kill    6
-#define SYS_exec    7
-#define SYS_fstat   8
-#define SYS_chdir   9
-#define SYS_dup    10
+#define SYS_fork 1
+#define SYS_exit 2
+#define SYS_wait 3
+#define SYS_pipe 4
+#define SYS_read 5
+#define SYS_kill 6
+#define SYS_exec 7
+#define SYS_fstat 8
+#define SYS_chdir 9
+#define SYS_dup 10
 #define SYS_getpid 11
-#define SYS_sbrk   12
-#define SYS_sleep  13
+#define SYS_sbrk 12
+#define SYS_sleep 13
 #define SYS_uptime 14
-#define SYS_open   15
-#define SYS_write  16
-#define SYS_mknod  17
+#define SYS_open 15
+#define SYS_write 16
+#define SYS_mknod 17
 #define SYS_unlink 18
-#define SYS_link   19
-#define SYS_mkdir  20
-#define SYS_close  21
+#define SYS_link 19
+#define SYS_mkdir 20
+#define SYS_close 21
+#define SYS_kmtk 22
+#define SYS_myfds 23
\ No newline at end of file
diff --git a/kernel/syskmtk.c b/kernel/syskmtk.c
new file mode 100644
index 0000000..0200360
--- /dev/null
+++ b/kernel/syskmtk.c
@@ -0,0 +1,28 @@
+#include "types.h"
+#include "param.h"
+#include "memlayout.h"
+#include "riscv.h"
+#include "spinlock.h"
+#include "proc.h"
+#include "syscall.h"
+#include "defs.h"
+
+int sys_kmtk(void)
+{
+    return 1414124;
+}
+
+int sys_myfds(void)
+{
+    int result_num = 0;
+    struct proc *p = myproc();
+
+    for (int i = 0; i < NOFILE; i++)
+    {
+        if (p->ofile[i] != 0)
+        {
+            result_num += 1 << i;
+        }
+    }
+    return result_num;
+}
\ No newline at end of file
diff --git a/more.c b/more.c
new file mode 100644
index 0000000..a335f3c
--- /dev/null
+++ b/more.c
@@ -0,0 +1,59 @@
+#include <stdio.h>    // 標準入出力関連の関数を使用するためのヘッダ
+#include <stdlib.h>   // 汎用ユーティリティ関数（exitなど）を使用するためのヘッダ
+#include <unistd.h>   // UNIX標準API（fork, pipe, read, writeなど）を使用するためのヘッダ
+#include <fcntl.h>    // ファイル制御（open関数など）を使用するためのヘッダ
+#include <sys/wait.h> // プロセス制御（wait関数）を使用するためのヘッダ
+
+int main(int ac, char *av[])
+{
+    int fds[2];    // パイプ用のファイルディスクリプタ配列
+    int infd;      // 入力ファイルのファイルディスクリプタ
+    int cc;        // 読み込んだバイト数を保存する変数
+    char buf[512]; // ファイルから読み込むデータを一時的に保存するバッファ
+    pid_t pid;     // プロセスIDを保存する変数
+    int status;    // 子プロセスの終了ステータスを保存する変数
+
+    // 引数の数が正しくない場合、エラーメッセージを表示して終了
+    if (ac != 2)
+    {
+        fprintf(stderr, "usage: %s file\n", av[0]);
+        exit(1);
+    }
+
+    // 指定されたファイルを読み取り専用でオープン
+    if ((infd = open(av[1], O_RDONLY)) < 0)
+    {
+        fprintf(stderr, "Cannot open: %s\n", av[1]);
+        exit(1);
+    }
+
+    // パイプを作成
+    if (pipe(fds) < 0)
+    {
+        perror("pipe");
+        exit(1);
+    }
+
+    // 子プロセスを作成
+    if ((pid = fork()) == 0)
+    {
+        // 子プロセスの処理
+        close(0); // 標準入力を閉じる
+        if (dup(fds[0]) < 0)
+        { // パイプの読み込み端を標準入力に複製
+            perror("dup");
+            exit(1);
+        }
+        execl("/usr/bin/more", "more", (char *)0); // moreコマンドを実行
+        exit(0);                                   // moreの実行が終了したら子プロセスを終了
+    }
+
+    // 親プロセスの処理
+    while ((cc = read(infd, buf, sizeof(buf))) != 0)
+    {                           // ファイルからデータを読み込む
+        write(fds[1], buf, cc); // パイプの書き込み端にデータを書き込む
+    }
+    close(infd);   // 入力ファイルを閉じる
+    close(fds[1]); // パイプの書き込み端を閉じる
+    wait(&status); // 子プロセスの終了を待つ
+}
diff --git a/user/kmtk_test.c b/user/kmtk_test.c
new file mode 100644
index 0000000..6fe4d6f
--- /dev/null
+++ b/user/kmtk_test.c
@@ -0,0 +1,25 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+
+int main(int argc, char *argv[])
+{
+    int kmtk_result = myfds();
+    printf("kmtk() returned %d\n", kmtk_result);
+
+    int fds[2];
+    pipe(fds);
+
+    int kmtk_result2 = myfds();
+    printf("kmtk() returned %d\n", kmtk_result2);
+
+    close(fds[0]);
+    close(fds[1]);
+    close(0);
+    close(2);
+
+    int kmtk_result3 = myfds();
+    printf("kmtk() returned %d\n", kmtk_result3);
+
+    exit(0);
+}
diff --git a/user/more.c b/user/more.c
new file mode 100644
index 0000000..a69b28d
--- /dev/null
+++ b/user/more.c
@@ -0,0 +1,51 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+
+int main(int argc, char *argv[])
+{
+    int fds[2];
+    int fd;
+    int n;
+    char buf[512];
+
+    if (argc != 2)
+    {
+        printf(2, "usage: %s file\n", argv[0]);
+        exit(0);
+    }
+
+    if ((fd = open(argv[1], 0)) < 0)
+    { // O_RDONLYはxv6では通常0です
+        printf(2, "Cannot open %s\n", argv[1]);
+        exit(0);
+    }
+
+    if (pipe(fds) < 0)
+    {
+        printf(2, "pipe failed\n");
+        exit(0);
+    }
+
+    if (fork() == 0)
+    {
+        close(0);
+        dup(fds[0], 0);
+        close(fds[0]);
+        close(fds[1]);
+        char *args[] = {"more", 0}; // xv6ではexecを使用して直接配列を渡す
+        exec("more", args);
+        printf(2, "exec more failed\n");
+        exit(0);
+    }
+
+    close(fds[0]);
+    while ((n = read(fd, buf, sizeof(buf))) > 0)
+    {
+        write(fds[1], buf, n);
+    }
+    close(fd);
+    close(fds[1]);
+    wait(0);
+    exit(0);
+}
diff --git a/user/pipe_test.c b/user/pipe_test.c
new file mode 100644
index 0000000..6ba6041
--- /dev/null
+++ b/user/pipe_test.c
@@ -0,0 +1,38 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+
+int main(void)
+{
+    int p[2];
+    char *argv[2];
+    argv[1] = 0;
+
+    // パイプ作成
+    pipe(p);
+
+    if (fork() == 0)
+    {
+        // 子プロセス
+        close(1);    // 標準出力を閉じる
+        dup(p[1]);   // パイプの書き込み側を標準出力に複製
+        close(p[0]); // パイプの読み込み側は不要なので閉じる
+        close(p[1]);
+
+        argv[0] = "ls";
+        exec("ls", argv);
+        exit(1);
+    }
+    else
+    {
+        // 親プロセス
+        close(0);    // 標準入力を閉じる
+        dup(p[0]);   // パイプの読み込み側を標準入力に複製
+        close(p[1]); // パイプの書き込み側は不要なので閉じる
+        close(p[0]);
+
+        argv[0] = "wc";
+        exec("wc", argv);
+    }
+    exit(0);
+}
diff --git a/user/prime.c b/user/prime.c
new file mode 100644
index 0000000..11594ef
--- /dev/null
+++ b/user/prime.c
@@ -0,0 +1,65 @@
+#include "kernel/types.h"
+#include "user/user.h"
+
+void sieve(int read_fd)
+{
+    int prime;
+    if (read(read_fd, &prime, sizeof(prime)) <= 0)
+    {
+        close(read_fd);
+        exit(0);
+    }
+
+    printf("prime %d\n", prime);
+
+    int new_fd[2];
+    pipe(new_fd);
+
+    if (fork() == 0)
+    {
+        close(new_fd[1]); // 新しい子プロセスで書き込み端を閉じる
+        sieve(new_fd[0]); // レシーブ側パイプで再帰的に呼び出し
+    }
+    else
+    {
+        close(new_fd[0]); // 親プロセスでは読み込み端を閉じる
+        int num;
+        while (read(read_fd, &num, sizeof(num)) > 0)
+        {
+            if (num % prime != 0)
+            {
+                write(new_fd[1], &num, sizeof(num)); // 割り切れない数を次のプロセスに渡す
+            }
+        }
+        close(new_fd[1]);
+        wait(0); // 子プロセスの終了を待つ
+        close(read_fd);
+        exit(0);
+    }
+}
+
+int main(int argc, char *argv[])
+{
+    int check_max = 1000000000;
+    int fds[2];
+
+    pipe(fds);
+
+    if (fork() != 0)
+    {
+        close(fds[0]); // 親プロセスは読み込み側を閉じる
+        for (int i = 2; i <= check_max; i++)
+        {
+            write(fds[1], &i, sizeof(i));
+        }
+        close(fds[1]); // 数値の書き込み完了後に書き込み側を閉じる
+        wait(0);       // 子プロセスの終了を待つ
+    }
+    else
+    {
+        close(fds[1]); // 子プロセスは書き込み側を閉じる
+        sieve(fds[0]); // 読み込み側で数値をフィルタリング
+    }
+
+    exit(0);
+}
diff --git a/user/pwd.c b/user/pwd.c
new file mode 100644
index 0000000..ab0cbb4
--- /dev/null
+++ b/user/pwd.c
@@ -0,0 +1,84 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+#include "kernel/fs.h"
+
+#define BUF_SIZE 512
+
+void strncpy(char *dst, const char *src, int n)
+{
+    int i;
+    for (i = 0; i < n && src[i] != '\0'; i++)
+    {
+        dst[i] = src[i];
+    }
+    for (; i < n; i++)
+    {
+        dst[i] = '\0';
+    }
+}
+
+void get_path(int fd, char *path)
+{
+    int fd_parent;
+    struct dirent de;
+    struct stat st, st_parent;
+
+    if (fstat(fd, &st) < 0)
+    {
+        fprintf(2, "Error: Cannot stat directory.\n");
+        return;
+    }
+
+    fd_parent = open("..", 0);
+    if (fd_parent < 0)
+    {
+        fprintf(2, "Error: Cannot open parent directory.\n");
+        return;
+    }
+
+    if (fstat(fd_parent, &st_parent) < 0)
+    {
+        fprintf(2, "Error: Cannot stat parent directory.\n");
+        close(fd_parent);
+        return;
+    }
+
+    while (read(fd_parent, &de, sizeof(de)) == sizeof(de))
+    {
+        if (de.inum == 0)
+            continue;
+        if (de.inum == st.ino)
+        {
+            strncpy(path + strlen(path), "/", 1);
+            strncpy(path + strlen(path), de.name, DIRSIZ);
+            break;
+        }
+    }
+
+    close(fd_parent);
+
+    if (st.ino != st_parent.ino)
+    {
+        get_path(fd_parent, path);
+    }
+}
+
+int main(int argc, char *argv[])
+{
+    char path[BUF_SIZE] = {0};
+    int fd;
+
+    fd = open(".", 0);
+    if (fd < 0)
+    {
+        fprintf(2, "Error: Cannot open current directory.\n");
+        exit(1);
+    }
+
+    get_path(fd, path);
+    printf("%s\n", path);
+
+    close(fd);
+    exit(0);
+}
diff --git a/user/simple_shell.c b/user/simple_shell.c
new file mode 100644
index 0000000..208844e
--- /dev/null
+++ b/user/simple_shell.c
@@ -0,0 +1,54 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+#include "kernel/fs.h"
+
+char buf[100];
+
+void simple_shell()
+{
+    int pid, wpid;
+    while (1)
+    {
+        // プロンプト表示
+        write(1, "$$$ ", 2);
+
+        // コマンド入力
+        memset(buf, 0, sizeof(buf));
+        gets(buf, sizeof(buf));
+        buf[strlen(buf) - 1] = 0; // 改行文字の削除
+
+        if (buf[0] == 0)
+            continue; // 入力がない場合はスキップ
+
+        // exitコマンド
+        if (strcmp(buf, "exit") == 0)
+        {
+            exit(0);
+        }
+
+        // コマンド実行
+        if ((pid = fork()) == 0)
+        {
+            // 子プロセスでコマンド実行
+            char *argv[2];
+            argv[0] = buf; // コマンド
+            argv[1] = 0;   // 引数の終わり
+            exec(buf, argv);
+            printf("exec %s failed\n", buf);
+            exit(1);
+        }
+        else
+        {
+            // 親プロセスで子プロセスの終了を待つ
+            while ((wpid = wait((int *)0)) >= 0 && wpid != pid)
+                ; // 子プロセスの終了を待つ
+        }
+    }
+}
+
+int main(void)
+{
+    simple_shell();
+    exit(0);
+}
diff --git a/user/user.h b/user/user.h
index 4d398d5..c28ac62 100644
--- a/user/user.h
+++ b/user/user.h
@@ -3,39 +3,41 @@ struct stat;
 // system calls
 int fork(void);
 int exit(int) __attribute__((noreturn));
-int wait(int*);
-int pipe(int*);
-int write(int, const void*, int);
-int read(int, void*, int);
+int wait(int *);
+int pipe(int *);
+int write(int, const void *, int);
+int read(int, void *, int);
 int close(int);
 int kill(int);
-int exec(const char*, char**);
-int open(const char*, int);
-int mknod(const char*, short, short);
-int unlink(const char*);
-int fstat(int fd, struct stat*);
-int link(const char*, const char*);
-int mkdir(const char*);
-int chdir(const char*);
+int exec(const char *, char **);
+int open(const char *, int);
+int mknod(const char *, short, short);
+int unlink(const char *);
+int fstat(int fd, struct stat *);
+int link(const char *, const char *);
+int mkdir(const char *);
+int chdir(const char *);
 int dup(int);
 int getpid(void);
-char* sbrk(int);
+char *sbrk(int);
 int sleep(int);
 int uptime(void);
+int kmtk(void);
+int myfds(void);
 
 // ulib.c
-int stat(const char*, struct stat*);
-char* strcpy(char*, const char*);
-void *memmove(void*, const void*, int);
-char* strchr(const char*, char c);
-int strcmp(const char*, const char*);
-void fprintf(int, const char*, ...);
-void printf(const char*, ...);
-char* gets(char*, int max);
-uint strlen(const char*);
-void* memset(void*, int, uint);
-void* malloc(uint);
-void free(void*);
-int atoi(const char*);
+int stat(const char *, struct stat *);
+char *strcpy(char *, const char *);
+void *memmove(void *, const void *, int);
+char *strchr(const char *, char c);
+int strcmp(const char *, const char *);
+void fprintf(int, const char *, ...);
+void printf(const char *, ...);
+char *gets(char *, int max);
+uint strlen(const char *);
+void *memset(void *, int, uint);
+void *malloc(uint);
+void free(void *);
+int atoi(const char *);
 int memcmp(const void *, const void *, uint);
 void *memcpy(void *, const void *, uint);
diff --git a/user/usys.pl b/user/usys.pl
index 01e426e..424436c 100755
--- a/user/usys.pl
+++ b/user/usys.pl
@@ -14,7 +14,7 @@ sub entry {
     print " ecall\n";
     print " ret\n";
 }
-	
+
 entry("fork");
 entry("exit");
 entry("wait");
@@ -36,3 +36,5 @@ entry("getpid");
 entry("sbrk");
 entry("sleep");
 entry("uptime");
+entry("kmtk");
+entry("myfds");
\ No newline at end of file
